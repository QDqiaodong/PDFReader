/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <stdio.h>
#include <string.h>
#include <android/log.h>
/* Header for class com_okay_reader_plugin_utils_JNICall */

#ifndef _Included_com_okay_reader_plugin_utils_JNICall
#define _Included_com_okay_reader_plugin_utils_JNICall
#define TAG    "my-jni-test" // 这个是自定义的LOG的标识
#define LOGD(...)  __android_log_print(ANDROID_LOG_DEBUG,TAG,__VA_ARGS__) // 定义LOGD类型
#ifdef __cplusplus
extern "C" {
#endif


/*
 * Class:     com_okay_reader_plugin_utils_JNICall
 * Method:    encrypt
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_okay_reader_plugin_utils_JNICall_encrypt
  (JNIEnv *env, jclass jobj, jstring jstr){
    char *rtn = NULL;
    //1.将传入的string转换成byte数组
    jclass clsstring = (*env)->FindClass(env, "java/lang/String");
    jstring strencode = (*env)->NewStringUTF(env, "GB2312");
    jmethodID mid = (*env)->GetMethodID(env, clsstring, "getBytes", "(Ljava/lang/String;)[B");
    jbyteArray barr = (jbyteArray) (*env)->CallObjectMethod(env, jstr, mid, strencode);

    //2.获取长度
    jsize alen = (*env)->GetArrayLength(env, barr);
    //3.得到数据的首地址
    jbyte *ba = (*env)->GetByteArrayElements(env, barr, JNI_FALSE);
    //LOGD("########## alen %d", alen);

    //4.得到C语言的字符串
    if (alen > 0) {
        rtn = (char *) malloc(alen + 1);
        memcpy(rtn, ba, alen);
        // LOGD("########## rtn %s", rtn);
        rtn[alen] = 0;
    }

    int key = 0x12;
    int i = 0;
    for (i = 0; i < alen; i++) {
        *(rtn + i) ^= key;
    }

    //8.释放资源
    (*env)->ReleaseByteArrayElements(env, barr, ba, 0);
    return (*env)->NewStringUTF(env, rtn);
}

#ifdef __cplusplus
}
#endif
#endif
